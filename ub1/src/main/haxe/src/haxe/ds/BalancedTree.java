// Generated by Haxe 4.1.5
package haxe.ds;

import haxe.root.*;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class BalancedTree<K, V> extends haxe.lang.HxObject implements haxe.IMap<K, V>
{
	public BalancedTree(haxe.lang.EmptyObject empty)
	{
	}
	
	
	public BalancedTree()
	{
		//line 41 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		haxe.ds.BalancedTree.__hx_ctor_haxe_ds_BalancedTree(((haxe.ds.BalancedTree<K, V>) (this) ));
		//line 41 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		java.lang.Object __temp_expr1 = ((java.lang.Object) (null) );
	}
	
	
	protected static <K_c, V_c> void __hx_ctor_haxe_ds_BalancedTree(haxe.ds.BalancedTree<K_c, V_c> __hx_this)
	{
	}
	
	
	public haxe.ds.TreeNode<K, V> root;
	
	public void set(K key, V value)
	{
		//line 51 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		this.root = this.setLoop(key, value, this.root);
	}
	
	
	public java.lang.Object get(K key)
	{
		//line 62 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		haxe.ds.TreeNode<K, V> node = this.root;
		//line 63 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		while (( node != null ))
		{
			//line 64 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			int c = this.compare(key, node.key);
			//line 65 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (( c == 0 )) 
			{
				//line 66 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return node.value;
			}
			
			//line 67 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (( c < 0 )) 
			{
				//line 68 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				node = node.left;
			}
			else
			{
				//line 70 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				node = node.right;
			}
			
		}
		
		//line 72 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		return null;
	}
	
	
	public boolean remove(K key)
	{
		//line 86 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		try 
		{
			//line 86 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			try 
			{
				//line 87 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				this.root = this.removeLoop(key, this.root);
				//line 88 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return true;
			}
			catch (java.lang.Throwable _g)
			{
				//line 86 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				if (( ((java.lang.Object) (haxe.Exception.caught(_g).unwrap()) ) instanceof java.lang.String )) 
				{
					//line 90 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
					return false;
				}
				else
				{
					//line 86 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
					throw _g;
				}
				
			}
			
			
		}
		catch (java.lang.Throwable typedException)
		{
			//line 85 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			throw ((java.lang.RuntimeException) (haxe.Exception.thrown(typedException)) );
		}
		
		
	}
	
	
	public boolean exists(K key)
	{
		//line 102 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		haxe.ds.TreeNode<K, V> node = this.root;
		//line 103 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		while (( node != null ))
		{
			//line 104 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			int c = this.compare(key, node.key);
			//line 105 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (( c == 0 )) 
			{
				//line 106 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return true;
			}
			else
			{
				//line 107 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				if (( c < 0 )) 
				{
					//line 108 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
					node = node.left;
				}
				else
				{
					//line 110 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
					node = node.right;
				}
				
			}
			
		}
		
		//line 112 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		return false;
	}
	
	
	public java.lang.Object keys()
	{
		//line 139 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		haxe.root.Array<K> ret = new haxe.root.Array<K>(( (K[]) (new java.lang.Object[] {}) ));
		//line 140 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		this.keysLoop(this.root, ret);
		//line 141 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		return new haxe.iterators.ArrayIterator<K>(((haxe.root.Array<K>) (ret) ));
	}
	
	
	public haxe.ds.TreeNode<K, V> setLoop(K k, V v, haxe.ds.TreeNode<K, V> node)
	{
		//line 151 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		if (( node == null )) 
		{
			//line 152 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			return new haxe.ds.TreeNode<K, V>(null, k, v, null, null);
		}
		
		//line 153 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		int c = this.compare(k, node.key);
		//line 154 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		if (( c == 0 )) 
		{
			//line 154 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			return new haxe.ds.TreeNode<K, V>(node.left, k, v, node.right, ( (( node == null )) ? (0) : (node._height) ));
		}
		else
		{
			//line 154 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (( c < 0 )) 
			{
				//line 155 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				haxe.ds.TreeNode<K, V> nl = this.setLoop(k, v, node.left);
				//line 156 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return this.balance(nl, node.key, node.value, node.right);
			}
			else
			{
				//line 158 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				haxe.ds.TreeNode<K, V> nr = this.setLoop(k, v, node.right);
				//line 159 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return this.balance(node.left, node.key, node.value, nr);
			}
			
		}
		
	}
	
	
	public haxe.ds.TreeNode<K, V> removeLoop(K k, haxe.ds.TreeNode<K, V> node)
	{
		//line 164 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		if (( node == null )) 
		{
			//line 165 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			throw ((java.lang.RuntimeException) (haxe.Exception.thrown("Not_found")) );
		}
		
		//line 166 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		int c = this.compare(k, node.key);
		//line 167 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		if (( c == 0 )) 
		{
			//line 167 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			return this.merge(node.left, node.right);
		}
		else
		{
			//line 168 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (( c < 0 )) 
			{
				//line 168 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return this.balance(this.removeLoop(k, node.left), node.key, node.value, node.right);
			}
			else
			{
				//line 169 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return this.balance(node.left, node.key, node.value, this.removeLoop(k, node.right));
			}
			
		}
		
	}
	
	
	public void keysLoop(haxe.ds.TreeNode<K, V> node, haxe.root.Array<K> acc)
	{
		//line 181 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		if (( node != null )) 
		{
			//line 182 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			this.keysLoop(node.left, acc);
			//line 183 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			acc.push(node.key);
			//line 184 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			this.keysLoop(node.right, acc);
		}
		
	}
	
	
	public haxe.ds.TreeNode<K, V> merge(haxe.ds.TreeNode<K, V> t1, haxe.ds.TreeNode<K, V> t2)
	{
		//line 189 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		if (( t1 == null )) 
		{
			//line 190 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			return t2;
		}
		
		//line 191 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		if (( t2 == null )) 
		{
			//line 192 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			return t1;
		}
		
		//line 193 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		haxe.ds.TreeNode<K, V> t = this.minBinding(t2);
		//line 194 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		return this.balance(t1, t.key, t.value, this.removeMinBinding(t2));
	}
	
	
	public haxe.ds.TreeNode<K, V> minBinding(haxe.ds.TreeNode<K, V> t)
	{
		//line 198 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		if (( t == null )) 
		{
			//line 198 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			throw ((java.lang.RuntimeException) (haxe.Exception.thrown("Not_found")) );
		}
		else
		{
			//line 198 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (( t.left == null )) 
			{
				//line 198 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return t;
			}
			else
			{
				//line 198 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return this.minBinding(t.left);
			}
			
		}
		
	}
	
	
	public haxe.ds.TreeNode<K, V> removeMinBinding(haxe.ds.TreeNode<K, V> t)
	{
		//line 202 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		if (( t.left == null )) 
		{
			//line 202 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			return t.right;
		}
		else
		{
			//line 202 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			return this.balance(this.removeMinBinding(t.left), t.key, t.value, t.right);
		}
		
	}
	
	
	public haxe.ds.TreeNode<K, V> balance(haxe.ds.TreeNode<K, V> l, K k, V v, haxe.ds.TreeNode<K, V> r)
	{
		//line 206 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		int hl = ( (( l == null )) ? (0) : (l._height) );
		//line 207 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		int hr = ( (( r == null )) ? (0) : (r._height) );
		//line 208 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		if (( hl > ( hr + 2 ) )) 
		{
			//line 209 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			haxe.ds.TreeNode<K, V> _this = l.left;
			//line 209 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			haxe.ds.TreeNode<K, V> _this1 = l.right;
			//line 209 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (( (( (( _this == null )) ? (0) : (_this._height) )) >= (( (( _this1 == null )) ? (0) : (_this1._height) )) )) 
			{
				//line 210 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return new haxe.ds.TreeNode<K, V>(l.left, l.key, l.value, new haxe.ds.TreeNode<K, V>(l.right, k, v, r, null), null);
			}
			else
			{
				//line 212 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return new haxe.ds.TreeNode<K, V>(new haxe.ds.TreeNode<K, V>(l.left, l.key, l.value, l.right.left, null), l.right.key, l.right.value, new haxe.ds.TreeNode<K, V>(l.right.right, k, v, r, null), null);
			}
			
		}
		else
		{
			//line 214 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (( hr > ( hl + 2 ) )) 
			{
				//line 215 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				haxe.ds.TreeNode<K, V> _this2 = r.right;
				//line 215 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				haxe.ds.TreeNode<K, V> _this3 = r.left;
				//line 215 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				if (( (( (( _this2 == null )) ? (0) : (_this2._height) )) > (( (( _this3 == null )) ? (0) : (_this3._height) )) )) 
				{
					//line 216 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
					return new haxe.ds.TreeNode<K, V>(new haxe.ds.TreeNode<K, V>(l, k, v, r.left, null), r.key, r.value, r.right, null);
				}
				else
				{
					//line 218 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
					return new haxe.ds.TreeNode<K, V>(new haxe.ds.TreeNode<K, V>(l, k, v, r.left.left, null), r.left.key, r.left.value, new haxe.ds.TreeNode<K, V>(r.left.right, r.key, r.value, r.right, null), null);
				}
				
			}
			else
			{
				//line 221 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return new haxe.ds.TreeNode<K, V>(l, k, v, r, ( (( (( hl > hr )) ? (hl) : (hr) )) + 1 ));
			}
			
		}
		
	}
	
	
	public int compare(K k1, K k2)
	{
		//line 226 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		return ((int) (haxe.root.Reflect.compare(((K) (k1) ), ((K) (k2) ))) );
	}
	
	
	@Override public java.lang.String toString()
	{
		//line 230 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		if (( this.root == null )) 
		{
			//line 230 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			return "{}";
		}
		else
		{
			//line 230 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			return ( ( "{" + this.root.toString() ) + "}" );
		}
		
	}
	
	
	@Override public java.lang.Object __hx_setField(java.lang.String field, java.lang.Object value, boolean handleProperties)
	{
		//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		{
			//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			boolean __temp_executeDef1 = true;
			//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (( field != null )) 
			{
				//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				switch (field.hashCode())
				{
					case 3506402:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("root")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							this.root = ((haxe.ds.TreeNode<K, V>) (value) );
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return value;
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
				}
				
			}
			
			//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (__temp_executeDef1) 
			{
				//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return super.__hx_setField(field, value, handleProperties);
			}
			else
			{
				//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				throw null;
			}
			
		}
		
	}
	
	
	@Override public java.lang.Object __hx_getField(java.lang.String field, boolean throwErrors, boolean isCheck, boolean handleProperties)
	{
		//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		{
			//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			boolean __temp_executeDef1 = true;
			//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (( field != null )) 
			{
				//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				switch (field.hashCode())
				{
					case -1776922004:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("toString")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "toString")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 3506402:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("root")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return this.root;
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 950484197:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("compare")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "compare")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 113762:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("set")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "set")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case -339185956:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("balance")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "balance")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 102230:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("get")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "get")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 277888887:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("removeMinBinding")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "removeMinBinding")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case -934610812:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("remove")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "remove")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case -757252141:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("minBinding")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "minBinding")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case -1289358244:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("exists")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "exists")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 103785528:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("merge")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "merge")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 3288564:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("keys")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "keys")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 518409912:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("keysLoop")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "keysLoop")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 1984755238:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("setLoop")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "setLoop")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 1098338632:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("removeLoop")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return ((haxe.lang.Function) (new haxe.lang.Closure(this, "removeLoop")) );
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
				}
				
			}
			
			//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (__temp_executeDef1) 
			{
				//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return super.__hx_getField(field, throwErrors, isCheck, handleProperties);
			}
			else
			{
				//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				throw null;
			}
			
		}
		
	}
	
	
	@Override public java.lang.Object __hx_invokeField(java.lang.String field, java.lang.Object[] dynargs)
	{
		//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		{
			//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			boolean __temp_executeDef1 = true;
			//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (( field != null )) 
			{
				//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				switch (field.hashCode())
				{
					case -1776922004:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("toString")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return this.toString();
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 113762:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("set")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							this.set(((K) (dynargs[0]) ), ((V) (dynargs[1]) ));
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 950484197:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("compare")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return this.compare(((K) (dynargs[0]) ), ((K) (dynargs[1]) ));
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 102230:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("get")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return this.get(((K) (dynargs[0]) ));
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case -339185956:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("balance")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return this.balance(((haxe.ds.TreeNode<K, V>) (dynargs[0]) ), ((K) (dynargs[1]) ), ((V) (dynargs[2]) ), ((haxe.ds.TreeNode<K, V>) (dynargs[3]) ));
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case -934610812:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("remove")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return this.remove(((K) (dynargs[0]) ));
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 277888887:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("removeMinBinding")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return this.removeMinBinding(((haxe.ds.TreeNode<K, V>) (dynargs[0]) ));
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case -1289358244:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("exists")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return this.exists(((K) (dynargs[0]) ));
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case -757252141:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("minBinding")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return this.minBinding(((haxe.ds.TreeNode<K, V>) (dynargs[0]) ));
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 3288564:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("keys")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return this.keys();
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 103785528:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("merge")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return this.merge(((haxe.ds.TreeNode<K, V>) (dynargs[0]) ), ((haxe.ds.TreeNode<K, V>) (dynargs[1]) ));
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 1984755238:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("setLoop")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return this.setLoop(((K) (dynargs[0]) ), ((V) (dynargs[1]) ), ((haxe.ds.TreeNode<K, V>) (dynargs[2]) ));
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 518409912:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("keysLoop")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							this.keysLoop(((haxe.ds.TreeNode<K, V>) (dynargs[0]) ), ((haxe.root.Array<K>) (dynargs[1]) ));
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
					case 1098338632:
					{
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						if (field.equals("removeLoop")) 
						{
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							__temp_executeDef1 = false;
							//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
							return this.removeLoop(((K) (dynargs[0]) ), ((haxe.ds.TreeNode<K, V>) (dynargs[1]) ));
						}
						
						//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
						break;
					}
					
					
				}
				
			}
			
			//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
			if (__temp_executeDef1) 
			{
				//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
				return super.__hx_invokeField(field, dynargs);
			}
			
		}
		
		//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		return null;
	}
	
	
	@Override public void __hx_getFields(haxe.root.Array<java.lang.String> baseArr)
	{
		//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		baseArr.push("root");
		//line 35 "/usr/local/lib/haxe/std/haxe/ds/BalancedTree.hx"
		super.__hx_getFields(baseArr);
	}
	
	
}


